---
layout: single
title:  "Java Script(this)"
categories: Java Script
tag: [foundation, JavaScript]
toc: true
author_profile: false
sidebar:
    nav: "docs"
typora-root-url: ../
---

# this

this는 함수 내에서 함수 호출 맥락(context)를 의미한다. 맥락이라는것은 상황에 따라서 달라진다는 의미인데 즉 함수를 어떻게 호출하느냐에 따라서 this가 가리키는 대상이 달라진다는 뜻이다.

this는 함수와 객체의 관계간 연결시켜주는 실질적인 연결점의 역할을 한다.

```javascript
        function func(){
            if(window === this){
                document.write("window === this");
            }
        }
        func();
```

위 예제를 실행했을때 this는 전역객체인 window와 같다는 것을 알 수 있다.

### 메소드의 호출

```javascript
        var o = {
            func : function(){
                if(o === this){
                    document.write("o === this");
                }
            }
        }
        o.func();
```

위 예제를 실행하면 o === this 즉, this는 객체의 자기 자신을 가리킨다.

맨 위 예제도 사실 window가 생략됬을뿐, window.func(); 이며 같은 예제라 볼 수 있다.

### 생성자와 this

```javascript
        var funcThis = null;
        function Func(){
            funcThis = this;
        }
        var o1 = Func();
        if(funcThis === window){
            document.write('window </br>');
        }

        var o2 = new Func();
        if(funcThis === o2){
            document.write('o2 <br>');
        }
```

위 예제에서 생성자 new의 빠짐의 차이점을 보고있다.

o1은 함수로만 호출한 것이고, o2는 생성자를 이용하여 호출한 것이다.

new를 추가하면 Func()는 생성자가 되어 새로운 객체를 생성한다.

+ 함수가 생성자로 사용될 경우,  this는 생성될 객체를 가리킨다.
+ 함수로 호출한다면 this는 window를 가리킨다.

### 객체로서 함수

```javascript
function sum(x,y){return x+y;}
sum(1,2);
var sum2 = new Function('x','y','return x+y;');
sum2(1,2);
```

위 결과는 똑같이 3으로 실행된다. 하지만 두 번째는 return 부분이 길어지면 사용하기 힘들다는 점이 있다.  sum(x,y){return x+y;} 는 sum이라고 하는 함수 객체를 만든것이다.

+ function sum(x,y){return x+y;} // 함수 리터럴
+ var o = { } 객체 리터럴
+ var a = [1,2,3] 배열 리터럴



